# CRM開発におけるGit構造の推奨事項

## 📋 概要

CRMの開発を開始するにあたり、Gitリポジトリを分けるべきかどうかを検討するためのドキュメントです。

## 🔍 現状の分析

### 現在の構造

- **CMS**: Next.jsアプリケーション（`/src/app/memories/`, `/src/app/admin/`など）
- **CRM**: 実装予定（`/src/app/admin/crm/`として計画）
- **共有リソース**:
  - Firestoreデータベース（`DATABASE_DESIGN.md`で共有）
  - Firebase Authentication
  - Firebase Functions
  - 共通コンポーネント（`AdminLayout`など）
  - Firestore Rules

### 実装計画

CRM_IMPLEMENTATION_PLAN.mdによると、CRMは以下の構造で実装予定：
```
src/app/admin/crm/
├── customers/
│   ├── page.tsx
│   └── [customerId]/page.tsx
├── orders/
│   ├── page.tsx
│   └── [orderId]/page.tsx
└── nfc-writer/
    └── page.tsx
```

## 🤔 Gitを分けるべきか？

### ✅ 分けるべき場合（モノレポから分離）

#### メリット
1. **プロジェクトの独立性**
   - CRMとCMSは異なる目的のアプリケーション
   - 独立したリリースサイクルで管理できる
   - デプロイの独立性（CRMだけをデプロイ可能）

2. **チーム構成**
   - 異なるチームで開発する場合、リポジトリを分けると管理しやすい
   - コードレビューの範囲が明確になる

3. **セキュリティ**
   - アクセス権限を細かく制御できる
   - 機密情報の管理が容易

4. **ビルド・デプロイの最適化**
   - CRMだけをビルド・デプロイできる
   - ビルド時間の短縮

#### デメリット
1. **コードの重複**
   - 共通コンポーネント（`AdminLayout`など）の重複
   - 型定義（`src/types/index.ts`）の重複
   - Firestore操作関数（`src/lib/firestore.ts`）の重複

2. **データベース設計の同期**
   - `DATABASE_DESIGN.md`の同期が必要
   - Firestore Rulesの同期が必要
   - スキーマ変更時の調整が複雑

3. **認証システムの共有**
   - Firebase Authenticationの設定を共有する必要がある
   - 認証コンテキスト（`useSecretKeyAuth`）の重複

4. **開発効率**
   - 2つのリポジトリを管理する必要がある
   - 変更の影響範囲が分かりにくい

### ❌ 分けない場合（モノレポで管理）

#### メリット
1. **コードの共有**
   - 共通コンポーネントを簡単に共有できる
   - 型定義を一元管理できる
   - Firestore操作関数を共有できる

2. **データベース設計の一元管理**
   - `DATABASE_DESIGN.md`を1箇所で管理
   - Firestore Rulesを1箇所で管理
   - スキーマ変更時の影響範囲が明確

3. **開発効率**
   - 1つのリポジトリで管理できる
   - 変更の影響範囲が分かりやすい
   - コードレビューが容易

4. **認証システムの共有**
   - 認証コンテキストを共有できる
   - Firebase設定を共有できる

#### デメリット
1. **デプロイの独立性**
   - CRMだけをデプロイする場合、CMSも一緒にデプロイされる
   - ビルド時間が長くなる可能性

2. **プロジェクトの独立性**
   - CRMとCMSが密結合になる
   - リリースサイクルが連動する

## 💡 推奨事項

### 🎯 推奨: **モノレポで管理（分けない）**

以下の理由から、**現時点ではGitを分けないことを推奨**します：

#### 1. データベース設計の共有
- `DATABASE_DESIGN.md`で全アプリケーション（CMS、LP、CRM、Functions等）で共有
- Firestore Rulesを1箇所で管理
- スキーマ変更時の影響範囲が明確

#### 2. 認証システムの共有
- 同じFirebase Authenticationを使用
- 認証コンテキスト（`useSecretKeyAuth`）を共有
- 権限管理（`role-check.ts`）を共有

#### 3. 共通コンポーネントの共有
- `AdminLayout`などの共通UIコンポーネント
- Firestore操作関数（`src/lib/firestore.ts`）
- 型定義（`src/types/index.ts`）

#### 4. 開発効率
- 1つのリポジトリで管理できる
- 変更の影響範囲が分かりやすい
- コードレビューが容易

#### 5. 実装計画との整合性
- CRM_IMPLEMENTATION_PLAN.mdでは`/admin/crm/`として計画
- 既存の`/admin/users/`と同じ構造

### 📁 推奨ディレクトリ構造

```
emolink-cms/
├── src/
│   ├── app/
│   │   ├── admin/
│   │   │   ├── users/          # 既存: ユーザー管理
│   │   │   ├── tenants/        # 既存: テナント管理
│   │   │   └── crm/            # 新規: CRM機能
│   │   │       ├── customers/
│   │   │       ├── orders/
│   │   │       └── nfc-writer/
│   │   ├── memories/           # 既存: CMS機能
│   │   └── ...
│   ├── components/
│   │   ├── admin-layout.tsx    # 共有: 管理画面レイアウト
│   │   └── ...
│   ├── lib/
│   │   ├── firestore.ts        # 共有: Firestore操作
│   │   ├── security/
│   │   │   ├── role-check.ts   # 新規: 権限チェック
│   │   │   └── tenant-validation.ts  # 共有: テナント検証
│   │   └── nfc/
│   │       └── writer.ts       # 新規: NFC書き込み
│   └── types/
│       └── index.ts            # 共有: 型定義
├── docs/
│   └── specifications/
│       └── DATABASE_DESIGN.md  # 共有: データベース設計
└── firestore.rules            # 共有: Firestore Rules
```

### 🔄 将来的に分ける場合の条件

以下の条件が満たされた場合、Gitを分けることを検討：

1. **プロジェクトの独立性が明確になった場合**
   - CRMとCMSが完全に独立したアプリケーションになった
   - 異なるリリースサイクルで管理する必要がある

2. **チーム構成が変わった場合**
   - 異なるチームで開発する必要がある
   - アクセス権限を細かく制御する必要がある

3. **デプロイの独立性が必要になった場合**
   - CRMだけをデプロイする必要がある
   - ビルド時間の短縮が必要

4. **コードの重複が許容できる場合**
   - 共通コンポーネントの重複が問題ない
   - データベース設計の同期が可能

## 🛠️ 実装時の注意事項

### モノレポで管理する場合

1. **ディレクトリ構造の明確化**
   - `/admin/crm/`でCRM機能を明確に分離
   - `/memories/`でCMS機能を明確に分離

2. **共通コードの管理**
   - `src/lib/`に共通関数を配置
   - `src/components/`に共通コンポーネントを配置
   - `src/types/`に共通型定義を配置

3. **Firestore Rulesの管理**
   - `firestore.rules`を1箇所で管理
   - CRMとCMSの両方のルールを含める

4. **デプロイの最適化**
   - 必要に応じて、デプロイスクリプトで特定のディレクトリだけをビルド
   - Firebase Hostingの設定でルーティングを最適化

### 将来的に分ける場合の準備

1. **共通コードの分離**
   - `src/lib/`を別パッケージとして分離（npmパッケージ化）
   - `src/types/`を別パッケージとして分離

2. **データベース設計の共有**
   - `DATABASE_DESIGN.md`を別リポジトリで管理
   - または、Git Submoduleとして管理

3. **認証システムの共有**
   - 認証コンテキストを別パッケージとして分離
   - Firebase設定を環境変数で管理

## 📊 比較表

| 項目 | モノレポ（推奨） | 分離 |
|------|----------------|------|
| **コードの共有** | ✅ 容易 | ❌ 重複が必要 |
| **データベース設計の管理** | ✅ 一元管理 | ⚠️ 同期が必要 |
| **認証システムの共有** | ✅ 容易 | ⚠️ 重複が必要 |
| **開発効率** | ✅ 高い | ⚠️ やや低い |
| **デプロイの独立性** | ⚠️ やや低い | ✅ 高い |
| **プロジェクトの独立性** | ⚠️ やや低い | ✅ 高い |
| **チーム構成** | ⚠️ やや制約あり | ✅ 柔軟 |

## ✅ 結論

**現時点では、モノレポで管理することを推奨します。**

理由：
1. データベース設計の共有が重要
2. 認証システムの共有が重要
3. 共通コンポーネントの共有が重要
4. 開発効率が高い
5. 実装計画との整合性

将来的に分ける必要が出てきた場合は、上記の「将来的に分ける場合の条件」を参考に判断してください。

---

**作成日**: 2025-01-26  
**最終更新日**: 2025-01-26  
**バージョン**: 1.0

